#' Creates a plottable data frame from a drug record
#' @param drugRec A drug record
#' @export
createDrugDF <- function(drugRec){

  drugDF <- as.data.frame(t(as.data.frame(drugRec, col.names = c(seq(1:length(drugRec))))))
  drugDF[1,]$V1 <- 0

  #Assign each individual drug an occurrence period of roughly one day
  drugDF$t_start <- cumsum(drugDF$V1)
  drugDF$regimen <- "No"
  drugDF$index <- c(1:length(drugDF$V1))

  #Assign each block a y-height
  drugDF$ymin <- -0.5
  drugDF$ymax <- 0.5
  j <- 0

  for(i in unique(drugDF$V2)){
    drugDF[drugDF$V2 == i,]$ymin <- drugDF[drugDF$V2 == i,]$ymin + (j*1.25)
    drugDF[drugDF$V2 == i,]$ymax <- drugDF[drugDF$V2 == i,]$ymax + (j*1.25)
    j = j + 1
  }

  colnames(drugDF) <- c("t_gap","component","t_start","regimen","index","ymin","ymax")

  drugDF$t_start <- as.numeric(drugDF$t_start)
  drugDF$t_end <- as.numeric(drugDF$t_start+0.9)
  drugDF$ymin <- as.numeric(drugDF$ymin)
  drugDF$ymax <- as.numeric(drugDF$ymax)

  return(drugDF)

}

#' Combines and removes overlapping regimens from an alignment output
#'
#' @param output An output dataframe created by align()
#' @param drugRec A drug record
#' @param drugDF A drugDF object generated by createDrugDF()
#' @param regimenCombine Allowed days between same regimen before being combined
#' @export
combineAndRemoveOverlaps <- function(output, drugRec, drugDF, regimenCombine) {

  outputDF <- output %>%
    dplyr::filter(.data$Score != "") %>%
    dplyr::select(regName, Score,
                  drugRec_Start, drugRec_End,
                  adjustedS, totAlign)

  regCount <- output[is.na(output$adjustedS),]

  regCount <- regCount %>%
    dplyr::rowwise() %>%
    dplyr::mutate(compNo = length(unique(gsub("[0-9]*\\.","",unlist(strsplit(.data$Regimen,";|~")))))) %>%
    dplyr::select(regName, compNo)

  regCount <- regCount[!duplicated(paste(regCount$regName, regCount$compNo)),]

  outputDF$drugRec_Start <- as.numeric(outputDF$drugRec_Start)
  outputDF$drugRec_End <- as.numeric(outputDF$drugRec_End)
  outputDF$totAlign <- as.numeric(outputDF$totAlign)

  outputDF <- outputDF %>%
    dplyr::arrange(.data$drugRec_Start)

  #outputDF$drugRec_Start <- outputDF$drugRec_Start + 1
  #outputDF$drugRec_End <- outputDF$drugRec_End + 1

  if(min(outputDF$drugRec_Start) <= 0){
    outputDF[outputDF$drugRec_Start <= 0,]$drugRec_Start <- 1
  }

  #if(max(outputDF$drugRec_End) > max(drugDF$index)){
  #  outputDF[outputDF$drugRec_End > max(drugDF$index),]$drugRec_End <- max(drugDF$index)
  #}

  outputDF$t_start <- drugDF[outputDF$drugRec_Start,]$t_start
  outputDF$t_end <- drugDF[outputDF$drugRec_End,]$t_start

  outputDF <- outputDF[order(outputDF$t_start, decreasing = F),]
  outputDF$index <- c(1:length(outputDF$drugRec_Start))
  toRemove <- c()

  #Overlap removal
  for(i in c(1:max(outputDF$index))){
    for(j in c(i:max(outputDF$index))){
      if(outputDF[i,]$regName != outputDF[j,]$regName) {
        if(outputDF[i,]$drugRec_Start <= outputDF[j,]$drugRec_End &
           outputDF[i,]$drugRec_End >= outputDF[j,]$drugRec_Start){
          if(!(i %in% toRemove) & !(j %in% toRemove)){
            sel <- outputDF[c(i,j),]

            i_score <- sel[sel$index==i,]$adjustedS
            j_score <- sel[sel$index==j,]$adjustedS

            if(i_score == j_score){
              toRemove <- toRemove
            } else {
              toRemove <- c(toRemove,sel[sel$adjustedS == min(sel$adjustedS),]$index)
            }
          }
        }
      }
    }
  }

  if(length(toRemove) > 0){
    outputDF <- outputDF[-toRemove,] %>%
      dplyr::arrange(.data$drugRec_Start)
  } else {
    outputDF <- outputDF %>%
      dplyr::arrange(.data$t_start)
  }

  # SECOND overlap removal - removing low component high soring regimens

  outputDF <- merge(outputDF,regCount,by = "regName")

  toRemove <- c()

  for(i in c(1:dim(outputDF)[1])){
    for(j in c(i:dim(outputDF)[1])) {
      if(i != j){
        if(outputDF[i,]$t_start < outputDF[j,]$t_end & outputDF[i,]$t_end > outputDF[j,]$t_start){
          mostComps <- max(outputDF[c(i,j),]$compNo)
          toRemove <- c(toRemove,c(i,j)[outputDF[c(i,j),]$compNo < mostComps])

          #if(outputDF[i,]$compNo == outputDF[j,]$compNo){
          #  toRemove <- c(toRemove,c(i,j)[grep(" RT",outputDF[c(i,j),]$regName)])
          #}
        }
      }
    }
  }

  toRemove <- unique(toRemove)

  if(length(toRemove) > 0){
    outputDF <- outputDF[-toRemove,] %>% dplyr::arrange(.data$t_start)
  } else {
    outputDF <- outputDF %>% dplyr::arrange(.data$t_start)
  }

  #Final overlap removal - sub-regimens
  toRemove <- c()

  for(i in c(1:dim(outputDF)[1])){
    for(j in c(i:dim(outputDF)[1])) {
      if(i != j){
        if(outputDF[i,]$regName == outputDF[j,]$regName){
          if(outputDF[i,]$totAlign == outputDF[j,]$totAlign){
            if(outputDF[i,]$t_start < outputDF[j,]$t_end & outputDF[j,]$t_start < outputDF[i,]$t_end){

              highScore <- max(outputDF[c(i,j),]$adjustedS)

              toRemove <- c(toRemove,c(i,j)[outputDF[c(i,j),]$adjustedS < highScore])

            }
          }
        }
      }
    }
  }

  toRemove <- unique(toRemove)

  if(length(toRemove) > 0){
    outputDF <- outputDF[-toRemove,] %>% dplyr::arrange(.data$t_start)
  } else {
    outputDF <- outputDF %>% dplyr::arrange(.data$t_start)
  }

  # Regimen Combine - overall combine

  outputDF$Score <- as.numeric(outputDF$Score)
  outputDF$index <- c(1:length(outputDF$drugRec_Start))

  output_Combine_All <- outputDF[0,]

  for(regimenCombi in unique(outputDF$regName)){
    outputTemp <- outputDF[outputDF$regName==regimenCombi,]
    outputTemp <- outputTemp %>%
      dplyr::mutate(prev_end = ifelse(.data$regName ==
                                        dplyr::lag(.data$regName),
                                      dplyr::lag(.data$t_end), 0))
    outputTemp[1,11] <- 0

    outputTemp <- outputTemp %>%
      dplyr::mutate(overlap = outputTemp$t_start <= outputTemp$prev_end+regimenCombine)

    outputTemp$combiIndex <- cumsum(c(0,as.numeric(outputTemp$overlap==FALSE)))[-1]

    output_summ_all <- outputTemp[0,]

    for(index in unique(outputTemp$combiIndex)) {

      outputTemp$adjustedS <- as.numeric(outputTemp$adjustedS)

      outputTemp_toSummarise <- outputTemp[outputTemp$combiIndex == index,] %>%
        dplyr::summarise(regName = unique(.data$regName),
                         Score = mean(.data$Score),
                         drugRec_Start = min(.data$drugRec_Start),
                         drugRec_End = max(.data$drugRec_End),
                         adjustedS = mean(.data$adjustedS),
                         t_start = min(.data$t_start),
                         t_end = max(.data$t_end),
                         totAlign = sum(.data$totAlign))

      output_summ_all <- rbind(output_summ_all,outputTemp_toSummarise)

    }

    output_Combine_All <- rbind(output_Combine_All,output_summ_all)

  }

  outputDF <- output_Combine_All %>%
    dplyr::arrange(.data$t_start)

  return(outputDF)

}

#' Plots, or returns a plot, displaying a full alignment output
#'
#' @param output An output dataframe created by align()
#' @param fontSize The desired font size of the text
#' @param regimenCombine Allowed number of days between two instances of the same regimen before
#' @param returnDat A toggle to also return a processed data object
#' @param returnDrugs A toggle to indicate whether drugs should be returned by processing,
#' in addition to regimens
#' @return regPlot - A ggplot object
#' @export
plotOutput <- function(output,
                       fontSize = 2.5,
                       regimenCombine = 28,
                       returnDat = F,
                       returnDrugs = F){

  eb <- ggplot2::element_blank()

  drugRec <- encode(output[is.na(output$Score)|output$Score=="",][1,]$DrugRecord)

  output <- output %>%
    dplyr::distinct()

  drugDF <- createDrugDF(drugRec)
  outputDF <- combineAndRemoveOverlaps(output, drugRec, drugDF, regimenCombine)

  outputDF$regimen <- "Yes"

  plotOutput <- outputDF %>%
    dplyr::select(t_start,
                  t_end,
                  regName,
                  regimen,
                  adjustedS)

  plotDrug <- drugDF %>%
    dplyr::select(t_start,
                  t_end,
                  component,
                  regimen)

  plotDrug$adjustedS <- "-1"
  colnames(plotOutput)[3] <- "component"

  plotDrug <- plotDrug %>%
    dplyr::mutate(component = strsplit(.data$component,"~")) %>%
    tidyr::unnest(component)

  plot <- rbind(plotDrug,plotOutput)

  ord <- unique(plot[order(plot$regimen,plot$t_start),]$component)

  plot$component <- factor(plot$component, levels = ord)

  breaks <- seq(-14, max(plot$t_end)+5, 1)
  tickLabels <- as.character(breaks)
  tickLabels[!(breaks %% 28 == 0)] <- ''

  overlapLines <- as.data.frame(matrix(ncol = 5))
  overlapT <- plot[plot$regimen == "Yes",]
  j <- 1

  if(dim(overlapT)[1] > 1){
    for(i in c(1:(dim(overlapT)[1]-1))){
      if(overlapT[i,]$component==overlapT[i+1,]$component){
        overlapLines[j,] <- c(as.numeric(overlapT[i,]$t_end),
                              as.numeric(overlapT[i+1,]$t_start),
                              as.character(overlapT[i,]$component),
                              "Line","0")
        j <- j + 1
      }
    }
  }

  colnames(overlapLines) <- colnames(plot)
  overlapLines$t_start <- as.numeric(overlapLines$t_start)
  overlapLines$t_end <- as.numeric(overlapLines$t_end)
  overlapLines$component <- factor(overlapLines$component, levels = ord)

  plot[plot$regimen=="Yes",]$t_start <- plot[plot$regimen=="Yes",]$t_start - 2
  plot[plot$regimen=="Yes",]$t_end <- plot[plot$regimen=="Yes",]$t_end + 2

  p1 <- ggplot2::ggplot(plot, ggplot2::aes(x = .data$t_start)) +
    ggplot2::geom_rect(data = plot[plot$regimen=="Yes",],
                           ggplot2::aes(ymin = as.numeric(.data$component)-0.3,
                                        ymax = as.numeric(.data$component)+0.3,
                                        xmin = .data$t_start,
                                        xmax = .data$t_end, fill = .data$component)) +
    ggplot2::geom_text(size = 3,
                       data = plot[plot$regimen=="Yes",],
                       ggplot2::aes(x = (.data$t_start+.data$t_end)/2,
                                    y = as.numeric(.data$component)+0.5,
                                    label=paste("S: ", round(100*as.numeric(.data$adjustedS),0)))) +
    ggplot2::geom_point(data = plot[plot$regimen=="No",], size = 3,
                        ggplot2::aes(x= .data$t_start,y= as.numeric(.data$component),
                                     fill = .data$component), shape = 21) +
    ggplot2::scale_y_continuous(labels = stringi::stri_trans_totitle(ord), breaks = seq(1,length(ord))) +
    ggplot2::scale_x_continuous(breaks = seq(0,max(plot$t_end),28)) +
    ggplot2::theme(panel.background = ggplot2::element_blank(),
                   panel.grid.major = ggplot2::element_line(colour = "grey95"),
                   legend.position = "none") +
    ggplot2::xlab("") + ggplot2::ylab("") +
    ggplot2::geom_segment(data = overlapLines, ggplot2::aes(y = as.numeric(.data$component),
                                                            yend = as.numeric(.data$component),
                                                            x = .data$t_start,
                                                            xend = .data$t_end,
                                                            colour = .data$component),
                          linetype = 2, lwd = 1) +
    ggplot2::scale_fill_viridis_d(drop=F) +
    ggplot2::scale_color_viridis_d(drop=F) +
    ggplot2::geom_hline(linetype = 3,
                        yintercept = table(plot[!duplicated(plot$component),]$regimen == "No")[2]+0.5)

  if(returnDat == TRUE){

    if(returnDrugs == TRUE){

      returnData <- rbind(plotDrug,plotOutput)

    } else {

      returnData <- plotOutput

    }

    returnData$personID <- unique(output$personID)

    return(returnData)

  } else {

    return(p1)

  }
}

#' Plot a full alignment output utilising an already
#' processed output
#' @param processedAll An output dataframe created by processAlignments
#' @param fontSize The desired font size of the text
#' @return regPlot - A ggplot object
#' @export
plotProcesssed <- function(processedAll,
                           fontSize = 2.5){

  plot <- processedAll

  ord <- unique(plot[order(plot$regimen,plot$t_start),]$component)

  plot$component <- factor(plot$component, levels = ord)

  breaks <- seq(-14, max(plot$t_end)+5, 1)
  tickLabels <- as.character(breaks)
  tickLabels[!(breaks %% 28 == 0)] <- ''

  overlapLines <- as.data.frame(matrix(ncol = 5))
  overlapT <- plot[plot$regimen == "Yes",]
  j <- 1

  if(dim(overlapT)[1] > 1){
    for(i in c(1:(dim(overlapT)[1]-1))){
      if(overlapT[i,]$component==overlapT[i+1,]$component){
        overlapLines[j,] <- c(as.numeric(overlapT[i,]$t_end),
                              as.numeric(overlapT[i+1,]$t_start),
                              as.character(overlapT[i,]$component),
                              "Line","0")
        j <- j + 1
      }
    }
  }

  colnames(overlapLines) <- colnames(plot)[1:5]
  overlapLines$t_start <- as.numeric(overlapLines$t_start)
  overlapLines$t_end <- as.numeric(overlapLines$t_end)
  overlapLines$component <- factor(overlapLines$component, levels = ord)

  plot[plot$regimen=="Yes",]$t_start <- plot[plot$regimen=="Yes",]$t_start - 2
  plot[plot$regimen=="Yes",]$t_end <- plot[plot$regimen=="Yes",]$t_end + 2

  p1 <- ggplot2::ggplot(plot, ggplot2::aes(x = .data$t_start)) +
    ggplot2::geom_rect(data = plot[plot$regimen=="Yes",],
                           ggplot2::aes(ymin = as.numeric(.data$component)-0.3,
                                        ymax = as.numeric(.data$component)+0.3,
                                        xmin = .data$t_start,
                                        xmax = .data$t_end, fill = .data$component)) +
    ggplot2::geom_text(size = 3,
                       data = plot[plot$regimen=="Yes",],
                       ggplot2::aes(x = (.data$t_start+.data$t_end)/2,
                                    y = as.numeric(.data$component)+0.5,
                                    label=paste("S: ", round(100*as.numeric(.data$adjustedS),0)))) +
    ggplot2::geom_point(data = plot[plot$regimen=="No",], size = 3,
                        ggplot2::aes(x= .data$t_start,y= as.numeric(.data$component),
                                     fill = .data$component), shape = 21) +
    ggplot2::scale_y_continuous(labels = stringi::stri_trans_totitle(ord), breaks = seq(1,length(ord))) +
    ggplot2::scale_x_continuous(breaks = seq(0,max(plot$t_end),28)) +
    ggplot2::theme(panel.background = ggplot2::element_blank(),
                   panel.grid.major = ggplot2::element_line(colour = "grey95"),
                   legend.position = "none") +
    ggplot2::xlab("") + ggplot2::ylab("") +
    ggplot2::geom_segment(data = overlapLines, ggplot2::aes(y = as.numeric(.data$component),
                                                            yend = as.numeric(.data$component),
                                                            x = .data$t_start,
                                                            xend = .data$t_end,
                                                            colour = .data$component),
                          linetype = 2, lwd = 1) +
    ggplot2::scale_fill_viridis_d(drop=F) +
    ggplot2::scale_color_viridis_d(drop=F) +
    ggplot2::geom_hline(linetype = 3,
                        yintercept = table(plot[!duplicated(plot$component),]$regimen == "No")[2]+0.5)

  return(p1)
}

#' Plots a plot displaying the observed score distribution for a given regimen, or two given regimens
#' processed output
#' @param processedAll An output dataframe created by processAlignments
#' @param regimen1 A regimen of interest
#' @param regimen2 An optional regimen of interest for comparison
#' @return regPlot - A ggplot object
#' @export
plotScoreDistribution <- function(regimen1,regimen2=NA,processedAll){

  scoreDistibution_All <- processedAll[,c("component","adjustedS")]
  colnames(scoreDistibution_All) <- c("regName","adjustedS")

  if(is.na(regimen2)){

    quantile(c(1,2,3))[[2]]
    quantile(c(1,2,3))[[4]]

    score_plot <- scoreDistibution_All[stringr::str_to_lower(scoreDistibution_All$regName) == stringr::str_to_lower(regimen1),]
    score_stats <- data.frame(statistic = c("median","percentile","percentile"),
                              linetype = c("median","percentile","percentile"),
                              value = c(median(score_plot$adjustedS),
                                        quantile(score_plot$adjustedS)[[2]],
                                        quantile(score_plot$adjustedS)[[4]]
                              )
    )

    ggplot2::ggplot(score_plot, ggplot2::aes(x=adjustedS)) +
      ggplot2::geom_histogram(binwidth = 0.01, color="darkblue",fill="grey80") +
      ggplot2::geom_density(alpha=.4, fill="lightblue") +
      ggplot2::geom_vline(data=score_stats, ggplot2::aes(xintercept=.data$value,linetype=.data$linetype), size=1, col="firebrick1") +
      ggplot2::scale_linetype_manual(name = "Stat.", breaks=c("median", "percentile"), values = c("solid","dashed")) +
      ggplot2::ggtitle(paste(regimen1)) +
      ggplot2::xlab("Density") +
      ggplot2::ylab("Adjusted Score") +
      ggplot2::theme_minimal() +
      ggplot2::labs(caption = paste("Mean: ",signif(mean(score_plot$adjustedS),2),"\n","Interquartile Range: ",signif(IQR(score_plot$adjustedS),3),sep=""))

  } else {

    score_plot <- scoreDistibution_All[stringr::str_to_lower(scoreDistibution_All$regName) == stringr::str_to_lower(regimen1),]
    score_stats <- data.frame(statistic = c("median","percentile","percentile"),
                              linetype = c("median","percentile","percentile"),
                              value = c(median(score_plot$adjustedS),
                                        quantile(score_plot$adjustedS)[[2]],
                                        quantile(score_plot$adjustedS)[[4]]
                              )
    )

    p1 <- ggplot2::ggplot(score_plot, ggplot2::aes(x=adjustedS)) +
      ggplot2::geom_histogram(binwidth = 0.01, color="darkblue",fill="grey80") +
      ggplot2::geom_density(alpha=.4, fill="lightblue") +
      ggplot2::geom_vline(data=score_stats, ggplot2::aes(xintercept=.data$value,linetype=.data$linetype), size=1, col="firebrick1") +
      ggplot2::scale_linetype_manual(name = "Stat.", breaks=c("median", "percentile"), values = c("solid","dashed")) +
      ggplot2::ggtitle(paste(regimen1)) +
      ggplot2::xlab("Density") +
      ggplot2::ylab("Adjusted Score") +
      ggplot2::theme_minimal() +
      ggplot2::labs(caption = paste("Mean: ",signif(mean(score_plot$adjustedS),2),"\n","Interquartile Range: ",signif(IQR(score_plot$adjustedS),3),sep=""))

    score_plot <- scoreDistibution_All[stringr::str_to_lower(scoreDistibution_All$regName) == stringr::str_to_lower(regimen2),]
    score_stats <- data.frame(statistic = c("median","percentile","percentile"),
                              linetype = c("median","percentile","percentile"),
                              value = c(median(score_plot$adjustedS),
                                        quantile(score_plot$adjustedS)[[2]],
                                        quantile(score_plot$adjustedS)[[4]]
                              )
    )

    p2 <- ggplot2::ggplot(score_plot, ggplot2::aes(x=adjustedS)) +
      ggplot2::geom_histogram(binwidth = 0.01, color="darkblue",fill="grey80") +
      ggplot2::geom_density(alpha=.4, fill="lightblue") +
      ggplot2::geom_vline(data=score_stats, ggplot2::aes(xintercept=.data$value,linetype=.data$linetype), size=1, col="firebrick1") +
      ggplot2::scale_linetype_manual(name = "Stat.", breaks=c("median", "percentile"), values = c("solid","dashed")) +
      ggplot2::ggtitle(paste(regimen2)) +
      ggplot2::xlab("Density") +
      ggplot2::ylab("Adjusted Score") +
      ggplot2::theme_minimal() +
      ggplot2::labs(caption = paste("Mean: ",signif(mean(score_plot$adjustedS),2),"\n","Interquartile Range: ",signif(IQR(score_plot$adjustedS),3),sep=""))

    gridExtra::grid.arrange(p1,p2,ncol=1)


  }

}


#' Plots a plot displaying the observed regimen length distribution for a given regimen, or two given regimens
#' processed output
#' @param processedAll An output dataframe created by processAlignments
#' @param regimen1 A regimen of interest
#' @param regimen2 An optional regimen of interest for comparison
#' @return regPlot - A ggplot object
#' @export
plotRegimenLengthDistribution <- function(regimen1,regimen2=NA,processedAll){

  processedAll$regLength <- 1+(processedAll$t_end - processedAll$t_start)

  scoreDistibution_All <- processedAll[,c("component","regLength")]
  colnames(scoreDistibution_All) <- c("regName","regLength")

  if(is.na(regimen2)){

    score_plot <- scoreDistibution_All[stringr::str_to_lower(scoreDistibution_All$regName) == stringr::str_to_lower(regimen1),]
    score_stats <- data.frame(statistic = c("median","percentile","percentile"),
                              linetype = c("median","percentile","percentile"),
                              value = c(median(score_plot$regLength),
                                        quantile(score_plot$regLength)[[2]],
                                        quantile(score_plot$regLength)[[4]]
                              )
    )


    ggplot2::ggplot(score_plot, ggplot2::aes(x=.data$regLength)) +
      ggplot2::geom_histogram(binwidth = 5, color="darkblue",fill="grey80") +
      ggplot2::geom_density(alpha=.4, fill="lightblue") +
      ggplot2::geom_vline(data=score_stats, ggplot2::aes(xintercept=.data$value,linetype=.data$linetype), size=1, col="firebrick1") +
      ggplot2::scale_linetype_manual(name = "Stat.", breaks=c("median", "percentile"), values = c("solid","dashed")) +
      ggplot2::ggtitle(paste(regimen1)) +
      ggplot2::xlab("Density") +
      ggplot2::ylab("Regimen Length") +
      ggplot2::theme_minimal() +
      ggplot2::labs(caption = paste("Median: ",signif(median(score_plot$regLength),2),"\n","Interquartile Range: ",signif(IQR(score_plot$regLength),3),sep=""))

  } else {

    score_plot <- scoreDistibution_All[stringr::str_to_lower(scoreDistibution_All$regName) == stringr::str_to_lower(regimen1),]
    score_stats <- data.frame(statistic = c("median","percentile","percentile"),
                              linetype = c("median","percentile","percentile"),
                              value = c(median(score_plot$regLength),
                                        quantile(score_plot$regLength)[[2]],
                                        quantile(score_plot$regLength)[[4]]
                              )
    )

    p1 <- ggplot2::ggplot(score_plot, ggplot2::aes(x=.data$regLength)) +
      ggplot2::geom_histogram(binwidth = 5, color="darkblue",fill="grey80") +
      ggplot2::geom_density(alpha=.4, fill="lightblue") +
      ggplot2::geom_vline(data=score_stats, ggplot2::aes(xintercept=.data$value,linetype=.data$linetype), size=1, col="firebrick1") +
      ggplot2::scale_linetype_manual(name = "Stat.", breaks=c("median", "percentile"), values = c("solid","dashed")) +
      ggplot2::ggtitle(paste(regimen1)) +
      ggplot2::xlab("Density") +
      ggplot2::ylab("Regimen Length") +
      ggplot2::theme_minimal() +
      ggplot2::labs(caption = paste("Median: ",signif(median(score_plot$regLength),2),"\n","Interquartile Range: ",signif(IQR(score_plot$regLength),3),sep=""))

    score_plot <- scoreDistibution_All[stringr::str_to_lower(scoreDistibution_All$regName) == stringr::str_to_lower(regimen2),]
    score_stats <- data.frame(statistic = c("median","percentile","percentile"),
                              linetype = c("median","percentile","percentile"),
                              value = c(median(score_plot$regLength),
                                        quantile(score_plot$regLength)[[2]],
                                        quantile(score_plot$regLength)[[4]]
                              )
    )

    p2 <- ggplot2::ggplot(score_plot, ggplot2::aes(x=.data$regLength)) +
      ggplot2::geom_histogram(binwidth = 5, color="darkblue",fill="grey80") +
      ggplot2::geom_density(alpha=.4, fill="lightblue") +
      ggplot2::geom_vline(data=score_stats, ggplot2::aes(xintercept=.data$value,linetype=.data$linetype), size=1, col="firebrick1") +
      ggplot2::scale_linetype_manual(name = "Stat.", breaks=c("median", "percentile"), values = c("solid","dashed")) +
      ggplot2::ggtitle(paste(regimen2)) +
      ggplot2::xlab("Density") +
      ggplot2::ylab("Adjusted Score") +
      ggplot2::theme_minimal() +
      ggplot2::labs(caption = paste("Median: ",signif(median(score_plot$regLength),2),"\n","Interquartile Range: ",signif(IQR(score_plot$regLength),3),sep=""))

    gridExtra::grid.arrange(p1,p2,ncol=1)


  }

}

#' Plots a plot displaying the frequency of the top N most frequent regimens
#' @param processedAll An output dataframe created by processAlignments
#' @param N The number of top rows to plot
#' @export
plotFrequency <- function(processedAll, N = 10){

  freqPlot <- as.data.frame(table(processedAll$component)/sum(table(processedAll$component)))
  freqPlot <- freqPlot[order(freqPlot$Freq, decreasing = T),]

  if(dim(freqPlot)[1] < N){
    N <- dim(freqPlot)[1]
  }

  freqPlot <- freqPlot[1:N,]
  freqPlot$Var1 <- factor(freqPlot$Var1, levels = freqPlot[order(freqPlot$Freq, decreasing = F),]$Var1)

  names <- freqPlot$Var1

  cols <- ggsci::pal_jco()(10)
  cols <- c(cols,ggsci::pal_jama()(7))

  if(N < 18){
    names(cols) <- names[sample(x = c(1:17))]
  } else{
    cols <- rep(cols,N)
    names(cols) <- names[sample(x = c(1:N))]
  }

  ggplot2::ggplot(freqPlot, ggplot2::aes(y=.data$Var1,x=.data$Freq,fill=.data$Var1)) +
    ggplot2::geom_bar(stat="identity") +
    ggplot2::scale_fill_manual(values = cols) +
    ggplot2::theme_minimal() +
    ggplot2::theme(legend.position = "none")
}


#' Plots a plot displaying the ERA frequency of the top N most frequent eras
#' @param processedEras An output dataframe created by calculateEras
#' @param N The number of top rows to plot
#' @export
plotErasFrequency <- function(processedEras, N = 10){
  firstLine <- processedEras[processedEras$First_Line==1,]
  firstLine_Tab <- as.data.frame(table(firstLine$component))

  secondLine <- processedEras[processedEras$Second_Line==1,]
  secondLine_Tab <- as.data.frame(table(secondLine$component))

  firstLine_Tab <- firstLine_Tab[order(firstLine_Tab$Freq, decreasing = T),]
  firstLine_Tab$Freq <- firstLine_Tab$Freq/sum(firstLine_Tab$Freq)

  firstLine_Tab.p <- firstLine_Tab[1:N,]

  firstLine_Tab.p$Var1 <- stringr::str_wrap(firstLine_Tab.p$Var1, width = 18)

  firstLine_Tab.p$Var1 <- factor(firstLine_Tab.p$Var1,
                                 levels = firstLine_Tab.p[order(firstLine_Tab.p$Freq, decreasing = F),]$Var1)

  secondLine_Tab <- secondLine_Tab[order(secondLine_Tab$Freq, decreasing = T),]
  secondLine_Tab$Freq <- secondLine_Tab$Freq/sum(secondLine_Tab$Freq)

  secondLine_Tab.p <- secondLine_Tab[1:N,]

  secondLine_Tab.p$Var1 <- stringr::str_wrap(secondLine_Tab.p$Var1, width = 18)

  secondLine_Tab.p$Var1 <- factor(secondLine_Tab.p$Var1,
                                  levels = secondLine_Tab.p[order(secondLine_Tab.p$Freq, decreasing = F),]$Var1)


  names <- as.character(unique(c(firstLine_Tab.p$Var1,secondLine_Tab.p$Var1)))

  cols <- ggsci::pal_jco()(10)
  cols <- c(cols,ggsci::pal_jama()(7))

  if(N < 18){
    names(cols) <- names[sample(x = c(1:17))]
  } else{
    cols <- rep(cols,N)
    names(cols) <- names[sample(x = c(1:N))]
  }

  fline <- ggplot2::ggplot(na.omit(firstLine_Tab.p), ggplot2::aes(x=.data$Var1,y=.data$Freq,fill=.data$Var1,col="black")) +
    ggplot2::geom_bar(stat = "identity") +
    ggplot2::theme(panel.background = ggplot2::element_blank(),
                   panel.grid.major = ggplot2::element_line(colour = "grey95"),
                   legend.position = "none") +
    ggplot2::scale_fill_manual(values = cols) +
    ggplot2::scale_color_manual(values = c("black" = "black")) +
    ggplot2::ylab("Frequency") + ggplot2::xlab("") + ggplot2::ggtitle("First Regimen") +
    ggplot2::coord_flip() +
    ggplot2::theme(
      axis.text.x = ggplot2::element_text(size = 14),
      axis.text.y = ggplot2::element_text(size = 15))

  sline <- ggplot2::ggplot(na.omit(secondLine_Tab.p), ggplot2::aes(x=.data$Var1,y=.data$Freq,fill=.data$Var1,col="black")) +
    ggplot2::geom_bar(stat = "identity") +
    ggplot2::theme(panel.background = ggplot2::element_blank(),
                   panel.grid.major = ggplot2::element_line(colour = "grey95"),
                   legend.position = "none") +
    ggplot2::scale_fill_manual(values = cols) +
    ggplot2::scale_color_manual(values = c("black" = "black")) +
    ggplot2::ylab("Frequency") + ggplot2::xlab("") + ggplot2::ggtitle("Second Regimen") +
    ggplot2::coord_flip() +
    ggplot2::theme(
      axis.text.x = ggplot2::element_text(size = 14),
      axis.text.y = ggplot2::element_text(size = 15))

  gridExtra::grid.arrange(fline,sline,ncol=2)
}

#' Plots a sankey diagram displaying the flow between first, second and third regimen eras
#' @param processedEras An output dataframe created by calculateEras
#' @param regGroups A dataframe indicating how to group regimens
#' @param saveLocation A file directory location where files may be saved
#' @param fileName A filename prefix for saved files
#' @export
plotSankey <- function(processedEras, regGroups, saveLocation = NA, fileName = "Network"){

  if(is.na(saveLocation)){
    saveLocation <- here::here()
  }

  firstLine <- processedEras[processedEras$First_Line==1,]
  firstLine_Tab <- as.data.frame(table(firstLine$component))

  secondLine <- processedEras[processedEras$Second_Line==1,]
  secondLine_Tab <- as.data.frame(table(secondLine$component))

  thirdLine <- processedEras[processedEras$Other==1,]
  thirdLine_Tab <- as.data.frame(table(thirdLine$component))

  sankey_first <- firstLine[,c(6,3)]
  sankey_sec <- secondLine[,c(6,3)]
  sankey_third <- thirdLine[,c(6,3)]

  colnames(sankey_first) <- c("personID","Var1")
  colnames(sankey_sec) <- c("personID","Var1")
  colnames(sankey_third) <- c("personID","Var1")

  colnames(regGroups) <- c("Var1","regGroup")

  sankey_first <- merge(sankey_first,regGroups,by="Var1")[,c(2,3)]
  sankey_sec <- merge(sankey_sec,regGroups,by="Var1")[,c(2,3)]
  sankey_third <- merge(sankey_third,regGroups,by="Var1")[,c(2,3)]

  colnames(sankey_first) <- c("personID","First Line")
  colnames(sankey_sec) <- c("personID","Second Line")
  colnames(sankey_third) <- c("personID","Subsequent Lines")

  sankey_all <- merge(merge(sankey_first,sankey_sec,all = T),sankey_third,all=T)
  sankey_all <- sankey_all[!duplicated(sankey_all$personID),]

  sankey_all[is.na(sankey_all$`Second Line`),]$`Second Line` <- ""
  sankey_all[is.na(sankey_all$`Subsequent Lines`),]$`Subsequent Lines` <- ""

  tt1 <- as.data.frame(table(reshape2::melt(sankey_all[,c(2,3)],
                                  id.vars = c("First Line","Second Line"), na.rm = F)))

  tt2 <- as.data.frame(table(reshape2::melt(sankey_all[,c(3,4)],
                                  id.vars = c("Second Line","Subsequent Lines"), na.rm = F)))


  tt1$First.Line <- as.character(tt1$First.Line)
  tt1$Second.Line <- as.character(tt1$Second.Line)
  tt2$Second.Line <- as.character(tt2$Second.Line)
  tt2$Subsequent.Lines <- as.character(tt2$Subsequent.Lines)

  tt1 <- tt1[!tt1$First.Line==tt1$Second.Line,]
  tt2 <- tt2[!tt2$Second.Line==tt2$Subsequent.Lines,]

  tt1$First.Line <- paste(tt1$First.Line,"(1st)",sep=" ")
  tt1$Second.Line <- paste(tt1$Second.Line,"(2nd)",sep=" ")

  tt2$Second.Line <- paste(tt2$Second.Line,"(2nd)",sep=" ")
  tt2$Subsequent.Lines <- paste(tt2$Subsequent.Lines,"(3rd)",sep=" ")

  colnames(tt1) <- c("source","target","value")
  colnames(tt2) <- c("source","target","value")

  links <- rbind(tt1,tt2)

  links <- links[!links$target %in% c(" (2nd)"," (3rd)"),]
  links <- links[!links$source %in% c(" (2nd)"," (3rd)"),]

  nodes <- data.frame(
    name=c(as.character(links$source),
           as.character(links$target)) %>% unique()
  )

  links$IDsource <- match(links$source, nodes$name)-1
  links$IDtarget <- match(links$target, nodes$name)-1

  p <- networkD3::sankeyNetwork(Links = links, Nodes = nodes,
                     Source = "IDsource", Target = "IDtarget",
                     Value = "value", NodeID = "name",
                     sinksRight=FALSE, width = 2200, height = 1000,
                     fontSize = 28, fontFamily = "calibri")

  networkFile <- paste(saveLocation,"/",fileName,".html",sep="")

  networkD3::saveNetwork(p, file = networkFile)

  webshot::webshot(url = networkFile, file = paste(saveLocation,"/",fileName,".png",sep=""), vwidth = 2200, vheight = 1000)


  }
